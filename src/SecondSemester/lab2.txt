public static List<Point> jarvisCalculate(List<Point> dots) {
        List<Point> hull = new ArrayList<>();
        Point minStartPoint = new Point(0, 0);
        for (Point dot : dots) {
            if (dot.y < minStartPoint.y) {
                minStartPoint.y = dot.y;
                minStartPoint.x = dot.x;
            } else if (dot.y == minStartPoint.y && dot.x < minStartPoint.x) {
                minStartPoint.x = dot.x;
            }
        }
        hull.add(minStartPoint);

        int min = 0;
        int i = 0;
        Point minSecondPoint = new Point(0, 0);
        double minAngle = 1;
        for (Point point : dots) {
            Point tempPoint = new Point(point.x - hull.get(0).x, point.y - hull.get(0).y);
            if (calculateAngle(tempPoint
                    , new Point(1, 0)) < minAngle) {
                minAngle = calculateAngle(tempPoint, new Point(1, 0));
                minSecondPoint = point;
                min = i;
            }
            i++;
        }
        hull.add(minSecondPoint);
        dots.remove(min);
//        dots.remove(minSecondPoint);

        int counter = 0;
        Point nextPoint = new Point(0, 0);
        while (true) {
            int d = 0;
            counter++;
            double maxAngel = -1.0;

            for (i = 0; i < dots.size(); i++) {

                Point tempPoint = new Point(hull.get(counter - 1).x - hull.get(counter).x, hull.get(counter - 1).y - hull.get(counter).y);
                double angle = calculateAngle(tempPoint, new Point(dots.get(i).x - hull.get(counter).x, dots.get(i).y - hull.get(counter).y));

                if (angle > maxAngel) {
                    nextPoint = dots.get(i);
                    maxAngel = angle;
                    d = i;
                }
            }

            if (nextPoint.x == hull.get(0).x && nextPoint.y == hull.get(0).y) {
                break;
            }

            hull.add(nextPoint);
            dots.remove(d);

        }
                Point startPoint = dots.get(0); //получаем первый элемент массива

        /* for (Point point : dots) {
                    if (startPoint.x > point.x) {
                        Collections.swap(dots, dots.indexOf(point), 0);
                        startPoint = point;
                    }
                }
                Point leftMinPoint = dots.remove(0);   // вытаскиваем первую точку, которая должна быть с самой левой координатой
                hull.add(leftMinPoint);
                dots.add(leftMinPoint);*/

        return hull;
    }

     private static double calculateAngle(Point firstPoint, Point secondPoint) {
            double angle = (firstPoint.x * secondPoint.x + firstPoint.y * secondPoint.y) / (Math.sqrt(firstPoint.x * firstPoint.x + firstPoint.y * firstPoint.y) * Math.sqrt(secondPoint.x * secondPoint.x + secondPoint.y * secondPoint.y)); ///
            if (angle < -1) {
                angle = -1;
            } else if (angle > 1) {
                angle = 1;
            }
            return angle;
        }